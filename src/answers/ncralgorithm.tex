\begin{answer}{ncralgorithm}
Let's use Python again.
Since we want to evaluate
\[
\binom{n}{k} = \frac{n!}{ (n-k)! k! }
\]
we need a function to calculate the factorial.
The  following code uses recursion to calculate it.
\begin{minted}{python}
def factorial(n):
    if n==0:
        return 1
    return(n * factorial(n-1) )

def nCr(n,k):
    return factorial(n)/(factorial(k) * factorial(n-k))
\end{minted}
For big numbers, this is expensive.
It is not necessary to call the factorial function three times.
Numerical overflow is also likely to occur if the nominator and denominator are both large.
We can devise a smarter solution.
Consider the following example with small integers.
\begin{align*}
\binom{8}{5} &= \frac{8!}{ (8-3)! 3! } \\
             &= \frac{(8 \times 7 \times 6 )}{3!} \\
             &= \frac{8 \times 7 \times 6 }{  3 \times 2 \times 1 }
\text{.}
\end{align*}
Likewise, the general case will be
\begin{align*}
\binom{n}{k}
             &= \frac
             { n \times (n-1) \times  \ldots \times (n-k+1) }
             { k \times (k-1) \times \ldots \times 1 }
\text{.}
\end{align*}
Since many of the integers in the nominator and denominator will cancel out, our function can exploit this, as the function below does. It also has improved numerical stability.
\begin{minted}{python}
def nCr_norecur(n,k):
    r = 1
    for i in range(k):
        r *= n-i
        r = r // (i+1)

    return r
\end{minted}
We can further optimise by noting that $\binom{n}{k}=\binom{n}{n-k}$ and always choosing to evaluate the one that is less work (for the function above, we prefer small values of $k$).
\end{answer}
